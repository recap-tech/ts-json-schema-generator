"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
describe("valid-data-type", () => {
    it("type-aliases-primitive", utils_1.assertValidSchema("type-aliases-primitive", "MyString"));
    it("type-aliases-object", utils_1.assertValidSchema("type-aliases-object", "MyAlias"));
    it("type-aliases-mixed", utils_1.assertValidSchema("type-aliases-mixed", "MyObject"));
    it("type-aliases-union", utils_1.assertValidSchema("type-aliases-union", "MyUnion"));
    it("type-aliases-anonymous", utils_1.assertValidSchema("type-aliases-anonymous", "MyObject"));
    it("type-aliases-local-namespace", utils_1.assertValidSchema("type-aliases-local-namespace", "MyObject"));
    it("type-aliases-recursive-anonymous", utils_1.assertValidSchema("type-aliases-recursive-anonymous", "MyAlias"));
    it("type-aliases-recursive-export", utils_1.assertValidSchema("type-aliases-recursive-export", "MyObject"));
    it("type-aliases-recursive-generics-anonymous", utils_1.assertValidSchema("type-aliases-recursive-generics-anonymous", "MyAlias"));
    it("type-aliases-recursive-generics-export", utils_1.assertValidSchema("type-aliases-recursive-generics-export", "MyAlias"));
    it("type-aliases-tuple", utils_1.assertValidSchema("type-aliases-tuple", "MyTuple"));
    it("type-aliases-tuple-empty", utils_1.assertValidSchema("type-aliases-tuple-empty", "MyTuple"));
    it("type-aliases-tuple-optional-items", utils_1.assertValidSchema("type-aliases-tuple-optional-items", "MyTuple"));
    it("type-aliases-tuple-rest", utils_1.assertValidSchema("type-aliases-tuple-rest", "MyTuple"));
    it("type-aliases-tuple-only-rest", utils_1.assertValidSchema("type-aliases-tuple-only-rest", "MyTuple"));
    it("type-maps", utils_1.assertValidSchema("type-maps", "MyObject"));
    it("type-primitives", utils_1.assertValidSchema("type-primitives", "MyObject"));
    it("type-union", utils_1.assertValidSchema("type-union", "TypeUnion"));
    it("type-union-tagged", utils_1.assertValidSchema("type-union-tagged", "Shape"));
    it("type-union-discriminated-simple", utils_1.assertValidSchema("type-union-discriminated-simple", "Shape"));
    it("type-union-discriminated-mixed", utils_1.assertValidSchema("type-union-discriminated-mixed", "Shape"));
    it("type-union-discriminated-enum", utils_1.assertValidSchema("type-union-discriminated-enum", "Shape"));
    it("type-intersection", utils_1.assertValidSchema("type-intersection", "MyObject"));
    it("type-intersection-conflict", utils_1.assertValidSchema("type-intersection-conflict", "MyObject"));
    it("type-intersection-partial-conflict", utils_1.assertValidSchema("type-intersection-partial-conflict", "MyType"));
    it("type-intersection-partial-conflict-ref", utils_1.assertValidSchema("type-intersection-partial-conflict", "MyType"));
    it("type-intersection-union", utils_1.assertValidSchema("type-intersection-union", "MyObject"));
    it("type-intersection-additional-props", utils_1.assertValidSchema("type-intersection-additional-props", "MyObject"));
    it("type-extend", utils_1.assertValidSchema("type-extend", "MyObject"));
    it("type-extend-circular", utils_1.assertValidSchema("type-extend-circular", "MyType"));
    it("type-typeof", utils_1.assertValidSchema("type-typeof", "MyType"));
    it("type-typeof-value", utils_1.assertValidSchema("type-typeof-value", "MyType"));
    it("type-typeof-enum", utils_1.assertValidSchema("type-typeof-enum", "MyObject"));
    it("type-typeof-class", utils_1.assertValidSchema("type-typeof-class", "MyObject"));
    it("type-indexed-access-tuple-1", utils_1.assertValidSchema("type-indexed-access-tuple-1", "MyType"));
    it("type-indexed-access-tuple-2", utils_1.assertValidSchema("type-indexed-access-tuple-2", "MyType"));
    it("type-indexed-access-tuple-union", utils_1.assertValidSchema("type-indexed-access-tuple-union", "FormLayout"));
    it("type-indexed-access-object-1", utils_1.assertValidSchema("type-indexed-access-object-1", "MyType"));
    it("type-indexed-access-object-2", utils_1.assertValidSchema("type-indexed-access-object-2", "MyType"));
    it("type-indexed-access-keyof", utils_1.assertValidSchema("type-indexed-access-keyof", "MyType"));
    it("type-keyof-tuple", utils_1.assertValidSchema("type-keyof-tuple", "MyType"));
    it("type-keyof-object", utils_1.assertValidSchema("type-keyof-object", "MyType"));
    it("type-keyof-object-function", utils_1.assertValidSchema("type-keyof-object-function", "MyType"));
    it("type-mapped-simple", utils_1.assertValidSchema("type-mapped-simple", "MyObject"));
    it("type-mapped-index", utils_1.assertValidSchema("type-mapped-index", "MyObject"));
    it("type-mapped-literal", utils_1.assertValidSchema("type-mapped-literal", "MyObject"));
    it("type-mapped-generic", utils_1.assertValidSchema("type-mapped-generic", "MyObject"));
    it("type-mapped-native", utils_1.assertValidSchema("type-mapped-native", "MyObject"));
    it("type-mapped-native-single-literal", utils_1.assertValidSchema("type-mapped-native-single-literal", "MyObject"));
    it("type-mapped-widened", utils_1.assertValidSchema("type-mapped-widened", "MyObject"));
    it("type-mapped-optional", utils_1.assertValidSchema("type-mapped-optional", "MyObject"));
    it("type-mapped-additional-props", utils_1.assertValidSchema("type-mapped-additional-props", "MyObject"));
    it("type-mapped-array", utils_1.assertValidSchema("type-mapped-array", "MyObject"));
    it("type-mapped-union-intersection", utils_1.assertValidSchema("type-mapped-union-intersection", "MyObject"));
    it("type-mapped-enum", utils_1.assertValidSchema("type-mapped-enum", "MyObject"));
    it("type-mapped-enum-optional", utils_1.assertValidSchema("type-mapped-enum-optional", "MyObject"));
    it("type-mapped-enum-null", utils_1.assertValidSchema("type-mapped-enum-null", "MyObject"));
    it("type-mapped-exclude", utils_1.assertValidSchema("type-mapped-exclude", "MyObject", "extended"));
    it("type-mapped-double-exclude", utils_1.assertValidSchema("type-mapped-double-exclude", "MyObject", "extended"));
    it("type-conditional-simple", utils_1.assertValidSchema("type-conditional-simple", "MyObject"));
    it("type-conditional-inheritance", utils_1.assertValidSchema("type-conditional-inheritance", "MyObject"));
    it("type-conditional-union", utils_1.assertValidSchema("type-conditional-union", "MyObject"));
    it("type-conditional-enum", utils_1.assertValidSchema("type-conditional-enum", "IParameter"));
    it("type-conditional-intersection", utils_1.assertValidSchema("type-conditional-intersection", "MyObject"));
    it("type-conditional-exclude", utils_1.assertValidSchema("type-conditional-exclude", "MyObject"));
    it("type-conditional-exclude-complex", utils_1.assertValidSchema("type-conditional-exclude-complex", "BaseAxisNoSignals"));
    it("type-conditional-exclude-narrowing", utils_1.assertValidSchema("type-conditional-exclude-narrowing", "MyObject"));
    it("type-conditional-narrowing", utils_1.assertValidSchema("type-conditional-narrowing", "MyObject"));
    it("type-conditional-omit", utils_1.assertValidSchema("type-conditional-omit", "MyObject"));
    it("type-conditional-jsdoc", utils_1.assertValidSchema("type-conditional-jsdoc", "MyObject", "extended"));
});
//# sourceMappingURL=valid-data-type.test.js.map